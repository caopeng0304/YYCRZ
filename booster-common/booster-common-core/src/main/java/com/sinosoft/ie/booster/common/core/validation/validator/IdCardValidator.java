package com.sinosoft.ie.booster.common.core.validation.validator;

import cn.hutool.core.util.StrUtil;
import com.sinosoft.ie.booster.common.core.validation.IdCard;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 校验身份证号码的长度、出生年月、地区码、第18位校验码的正确性
 *
 * @author haocy
 * @since 2021-08-19
 */
public class IdCardValidator implements ConstraintValidator<IdCard, String> {

	@Override
	public boolean isValid(String value, ConstraintValidatorContext context) {
		String validateResult = idCardValidate(value);
		if (validateResult != null) {
			//禁用默认的message的值
			context.disableDefaultConstraintViolation();
			context.buildConstraintViolationWithTemplate(validateResult)
					.addConstraintViolation();
			return false;
		}
		return true;
	}

	private String idCardValidate(String idStr) {
		// 判断号码不能为空
		if (StrUtil.isEmpty(idStr)) {
			return "身份证号码不能为空";
		}
		String ai = "";
		//将身份证最后一位的x转换为大写，便于统一
		idStr = idStr.toUpperCase();
		// 判断号码的长度 15位或18位
		if (idStr.length() != 15 && idStr.length() != 18) {
			return "身份证号码长度应该为15位或18位";
		}

		// 18位身份证前17位位数字，如果是15位的身份证则所有号码都为数字
		if (idStr.length() == 18) {
			ai = idStr.substring(0, 17);
		} else {
			ai = idStr.substring(0, 6) + "19" + idStr.substring(6, 15);
		}
		if (!isNumeric(ai)) {
			return "身份证15位号码都应为数字；18位号码除最后一位外，都应为数字";
		}

		// 判断出生年月是否有效
		String strYear = ai.substring(6, 10);// 年份
		String strMonth = ai.substring(10, 12);// 月份
		String strDay = ai.substring(12, 14);// 日期
		if (!isDate(strYear + "-" + strMonth + "-" + strDay)) {
			return "身份证出生日期无效";
		}
		GregorianCalendar gc = new GregorianCalendar();
		SimpleDateFormat s = new SimpleDateFormat("yyyy-MM-dd");
		try {
			if ((gc.get(Calendar.YEAR) - Integer.parseInt(strYear)) > 150
					|| (gc.getTime().getTime() - s.parse(
					strYear + "-" + strMonth + "-" + strDay).getTime()) < 0) {
				return "身份证生日不在有效范围";
			}
		} catch (NumberFormatException | ParseException e) {
			e.printStackTrace();
		}
		if (Integer.parseInt(strMonth) > 12 || Integer.parseInt(strMonth) == 0) {
			return "身份证月份无效";
		}
		if (Integer.parseInt(strDay) > 31 || Integer.parseInt(strDay) == 0) {
			return "身份证日期无效";
		}

		// 判断地区码是否有效
		Map<String, String> areacode = GetAreaCode();
		//如果身份证前两位的地区码不在Hashtable，则地区码有误
		if (areacode.get(ai.substring(0, 2)) == null) {
			return "身份证地区编码错误";
		}

		if (!isVerifyCode(ai, idStr)) {
			return "身份证校验码无效，不是合法的身份证号码";
		}

		return null;
	}

	/*
	 * 判断第18位校验码是否正确
	* 第18位校验码的计算方式：
	   　　1. 对前17位数字本体码加权求和
	   　　公式为：S = Sum(Ai * Wi), i = 0, ... , 16
	   　　其中Ai表示第i个位置上的身份证号码数字值，Wi表示第i位置上的加权因子，其各位对应的值依次为： 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2
	   　　2. 用11对计算结果取模
	   　　Y = mod(S, 11)
	   　　3. 根据模的值得到对应的校验码
	   　　对应关系为：
	   　　 Y值：     0  1  2  3  4  5  6  7  8  9  10
	   　　校验码： 1  0  X  9  8  7  6  5  4  3   2
	*/
	private boolean isVerifyCode(String ai, String idStr) {
		String[] verifyCode = {"1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"};
		String[] wi = {"7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"};
		int sum = 0;
		for (int i = 0; i < 17; i++) {
			sum = sum + Integer.parseInt(String.valueOf(ai.charAt(i))) * Integer.parseInt(wi[i]);
		}
		int modValue = sum % 11;
		String strVerifyCode = verifyCode[modValue];
		ai = ai + strVerifyCode;
		if (idStr.length() == 18) {
			return ai.equals(idStr);
		}
		return true;
	}

	/**
	 * 将所有地址编码保存在一个Map中
	 *
	 * @return Map 对象
	 */
	private static Map<String, String> GetAreaCode() {
		Map<String, String> map = new HashMap<>();
		map.put("11", "北京");
		map.put("12", "天津");
		map.put("13", "河北");
		map.put("14", "山西");
		map.put("15", "内蒙古");
		map.put("21", "辽宁");
		map.put("22", "吉林");
		map.put("23", "黑龙江");
		map.put("31", "上海");
		map.put("32", "江苏");
		map.put("33", "浙江");
		map.put("34", "安徽");
		map.put("35", "福建");
		map.put("36", "江西");
		map.put("37", "山东");
		map.put("41", "河南");
		map.put("42", "湖北");
		map.put("43", "湖南");
		map.put("44", "广东");
		map.put("45", "广西");
		map.put("46", "海南");
		map.put("50", "重庆");
		map.put("51", "四川");
		map.put("52", "贵州");
		map.put("53", "云南");
		map.put("54", "西藏");
		map.put("61", "陕西");
		map.put("62", "甘肃");
		map.put("63", "青海");
		map.put("64", "宁夏");
		map.put("65", "新疆");
		map.put("71", "台湾");
		map.put("81", "香港");
		map.put("82", "澳门");
		map.put("91", "国外");
		return map;
	}

	/**
	 * 判断字符串是否为数字,0-9重复0次或者多次
	 *
	 * @param strNum
	 * @return
	 */
	private boolean isNumeric(String strNum) {
		Pattern pattern = Pattern.compile("[0-9]*");
		Matcher isNum = pattern.matcher(strNum);
		return isNum.matches();
	}

	/**
	 * 功能：判断字符串出生日期是否符合正则表达式：包括年月日，闰年、平年和每月31天、30天和闰月的28天或者29天
	 *
	 * @param strDate
	 * @return
	 */
	private boolean isDate(String strDate) {
		Pattern pattern = Pattern
				.compile("^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))?$");
		Matcher m = pattern.matcher(strDate);
		return m.matches();
	}

	public static void main(String[] args) throws ParseException {
		IdCardValidator idCardValidator = new IdCardValidator();
		String idCards = "110101198008070024,110101198008070040,110101198008070067,110101198008070083," +
				"110101198008070104,110101198008070120,110101198008070147,110101198008070163," +
				"11010119800807018X,110101198008070200,110101198008070227,110101198008070243," +
				"11010119800807026X,110101198008070286,110101198008070307,110101198008070323," +
				"11010119800807034X,110101198008070366,110101198008070382,110101198008070403," +
				"11010119800807042X,110101198008070446,110101198008070462,110101198008070489," +
				"11010119800807050X,110101198008070526,110101198008070542,110101198008070569," +
				"110101198008070585,110101198008070606,110101198008070622,110101198008070649," +
				"110101198008070665,110101198008070681,110101198008070702,110101198008070729," +
				"110101198008070745,110101198008070761,110101198008070788,110101198008070809," +
				"110101198008070825,110101198008070841,110101198008070868,110101198008070884," +
				"110101198008070905,110101198008070921,110101198008070948,110101198008070964," +
				"110101198008070980,110101198008071000,110101198008071027,110101198008071043," +
				"11010119800807106X,110101198008071086,110101198008071107,110101198008071123," +
				"11010119800807114X,110101198008071166,110101198008071182,110101198008071203," +
				"11010119800807122X,110101198008071246,110101198008071262,110101198008071289," +
				"11010119800807130X,110101198008071326,110101198008071342,110101198008071369," +
				"110101198008071385,110101198008071406,110101198008071422,110101198008071449," +
				"110101198008071465,110101198008071481,110101198008071502,110101198008071529," +
				"110101198008071545,110101198008071561,110101198008071588,110101198008071609," +
				"110101198008071625,110101198008071641,110101198008071668,110101198008071684," +
				"110101198008071705,110101198008071721,110101198008071748,110101198008071764," +
				"110101198008071780,110101198008071801,110101198008071828,130402198008070012," +
				"130402198008070039,130402198008070055,130402198008070071,130402198008070098," +
				"130402198008070119,130402198008070135,130402198008070151,130402198008070178," +
				"130402198008070194,130402198008070215,130402198008070231,130402198008070258," +
				"130402198008070274,130402198008070290,130402198008070311,130402198008070338," +
				"130402198008070354,130402198008070370,130402198008070397,130402198008070418," +
				"130402198008070434,130402198008070450,130402198008070477,130402198008070493," +
				"130402198008070514,130402198008070530,130402198008070557,130402198008070573," +
				"13040219800807059X,130402198008070610,130402198008070637,130402198008070653," +
				"13040219800807067X,130402198008070696,130402198008070717,130402198008070733," +
				"13040219800807075X,130402198008070776,130402198008070792,130402198008070813," +
				"13040219800807083X,130402198008070856,130402198008070872,130402198008070899," +
				"13040219800807091X,130402198008070936,130402198008070952,130402198008070979," +
				"130402198008070995,130402198008071015,130402198008071031,130402198008071058," +
				"130402198008071074,130402198008071090,130402198008071111,130402198008071138," +
				"130402198008071154,130402198008071170,130402198008071197,130402198008071218," +
				"130402198008071234,130402198008071250,130402198008071277,130402198008071293," +
				"130402198008071314,130402198008071330,130402198008071357,130402198008071373," +
				"13040219800807139X,130402198008071410,130402198008071437,130402198008071453," +
				"13040219800807147X,130402198008071496,130402198008071517,130402198008071533," +
				"13040219800807155X,130402198008071576,130402198008071592,130402198008071613," +
				"13040219800807163X,130402198008071656,130402198008071672,130402198008071699," +
				"13040219800807171X,130402198008071736,130402198008071752,130402198008071779," +
				"130402198008071795,130402198008071816,130402198008071832,130402198008071859," +
				"130402198008071875,130402198008071891,130402198008071912,130402198008071939," +
				"130402198008071955,130402198008071971,130402198008071998,130402198008072018," +
				"130402198008072034,130402198008072050,130402198008072077,130402198008072093," +
				"130402198008072114,130402198008072130";
		Arrays.stream(idCards.split(",")).forEach(
				idCard -> System.out.println(idCardValidator.idCardValidate(idCard))
		);
	}
}
